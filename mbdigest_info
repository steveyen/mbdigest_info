#!/usr/bin/env ruby

def usage()
  print("mbdigest_info [options] ns_server.log ...\n")
  print("\n")
  print("  -h / --help\n")
  print("    Print this usage help message.\n")
  print("\n")
  print("  --html=<path/to/output-report.html>\n")
  print("    Emit a correlated analysis in html format.\n")
  print("\n")
  print("  --max-entries=<MAX_ENTRIES>\n")
  print("    Stop after processing MAX_ENTRIES in the log.\n")
  print("\n")
  exit
end

usage() if ARGV.include?('--help')
usage() if ARGV.include?('-h')

# --------------------------------------------------------

html        = (ARGV.select {|x| x =~ /^--html/}[-1] || "").split('=')[1]
MAX_ENTRIES = (ARGV.select {|x| x =~ /^--max-entries/}[-1] || "=-1").split('=')[1].to_i

ns_server_logs = ARGV.select {|x| !x.match(/^--/)}
ns_server_logs = ["ns_server.log"] if ns_server_logs.length <= 0

print "mbdigest_info #{ns_server_logs}\n"

# --------------------------------------------------------

def parse_ns_server_log_file(file, agg={}, opts={}, &block)
  File.open(file, 'rb') {|io| parse_ns_server_log_io(io, agg, opts, &block)}
end

def parse_ns_server_log_io(io, agg={}, opts={}, &block)
  opts ||= {}

  line_max = opts[:max_lines] || -1
  line_prev = nil

  entry_max = opts[:max_entries] || -1
  entry_curr = []
  entry_delim = "===============================================================================\n"

  pids = agg[:pids] || {}
  lines = 0
  entries = 0

  pid = ymd = tms = nil

  while (line_max < 0 or lines < line_max) and
        (entry_max < 0 or entries < entry_max)
    line = io.gets("\n")
    break unless line

    if line == entry_delim
      # The first entry is strangely missing a timestamp.
      #
      if entries > 0
        # Record tne first entry for a pid.
        #
        if pid
          pids[pid][3] = pids[pid][3] || entry_curr[0..-2]
        end

        block.call(entries, entry_curr[0..-2])
      end

      # Example header...
      # "INFO REPORT  <5881.69.0>                                    2011-06-05 22:01:05"
      #
      header = line_prev.split(' ')

      pid = header[2]
      ymd = header[-2]
      tms = header[-1]

      # An entry in pids looks like...
      #   ["#{ymd}:{tms}", pid, NumEntriesFromThisPid, FirstMessageFromThisPid]
      #
      pids[pid] = (pids[pid] || [ymd +":" + tms, pid, 0])
      pids[pid][2] += 1

      entries = entries + 1
      entry_curr = [[ymd, tms, pid]]
    else
      entry_curr << line
    end

    lines = lines + 1
    line_prev = line
  end

  block.call(entries, entry_curr[0..-2])

  print "MAX LINES REACHED: #{lines}\n" if line_max >= 0 and lines >= line_max
  print "MAX ENTRIES REACHED: #{entries}\n" if entry_max >= 0 and entries >= entry_max

  return pids, entries, lines
end

def dot(i)
  if i.modulo(1000) == 0
    print(".")
    STDOUT.flush
  end
  return i + 1
end

# --------------------------------------------------------

agg = { :pids => {} } # Some aggregate tracking during first pass.

ns_server_logs.each do |f|
  print "processing #{f}\n"

  i = 0
  pids, entries, lines = parse_ns_server_log_file(f, agg=agg, opts={ :max_entries => MAX_ENTRIES }) do |x, entry|
    i = dot(i)
  end

  print "\nDONE: #{lines} lines, #{entries} entries, #{pids.size} pids\n"
end

if html
  File.open(html, 'w') do |out|
    agg_pids = agg[:pids]
    agg_pids_idx = {} # Key is pid, value is index of pid in sorted agg_pids list.
    agg_pids.values.sort.each do |pid_info|
      pid = pid_info[1]
      agg_pids_idx[pid] = agg_pids_idx[pid] || agg_pids_idx.size
    end

    out.write("<html>\n")
    out.write("<body>\n")

    ns_server_logs.each do |f|
      print "html-processing #{f}\n"

      out.write("<h1>#{f}</h1>\n")
      out.write("<table>\n")
      out.write("<tr><th>time</th><td>events\n")

      last_ymd = last_tms = pid = ""

      i = 0
      pids, entries, lines = parse_ns_server_log_file(f, agg={}, opts={ :max_entries => MAX_ENTRIES }) do |x, entry|
        ymd, tms, pid = entry[0]
        # print("#{ymd} #{tms} #{pid} ----- #{i}\n#{entry[1..-1]}\n")

        if ymd != last_ymd or tms != last_tms
          out.write("</td></tr>\n<tr><td>#{ymd} #{tms}</td>\n<td>\n")
        end

        out.write("#{pid}\n")

        last_ymd = ymd
        last_tms = tms
        last_pid = pid

        i = dot(i)
      end

      out.write("<table>\n")

      print "\nDONE: #{lines} lines, #{entries} entries, #{pids.size} pids\n"
    end

    out.write("</body>\n")
    out.write("</html>\n")
  end
end


